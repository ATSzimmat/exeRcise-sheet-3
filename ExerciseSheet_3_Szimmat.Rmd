---
title: "Exercise #3"
subtitle: "Fortgeschrittene Statistische Software für NF"
author: "Anton Szimmat (12797237)"
date: "`r Sys.Date()`"
output: html_document
---

## Before we start

```{r message=FALSE}
# Loading the required packages
library(tidyverse)
library(Polychrome)
library(janitor)
library(viridisLite)
```

## Exercise 1: Initializing git (4 Points)

For this whole exercise sheet we will be tracking all our changes to it in git.

### a)

Start by initializing a new R project with git support, called `2025-exeRcise-sheet-3`. If you forgot how to do this, you can follow this [guide](https://malikaihle.github.io/Introduction-RStudio-Git-GitHub/rstudio_project.html).

### b)

Commit the files generated by Rstudio.

### c)

For all of the following tasks in this exercise sheet we ask you to always commit your changes after finishing each subtask e.g. create a commit after task 1d, 1e etc.

(Note: This applies only to answers that have text or code as their answer. If you complete tasks in a different order or forget to commit one, this is no problem. If you change your answers you can just create multiple commits to track the changes.)

### d)

Name 2 strengths and 2 weaknesses of git. (Don't forget to create a commit after this answer, see 1c)

-   Two strengths of git

    -   Git is really great for collaboration with other users and if you want to understand the changes done by other the persons you work with

    -   In most cases, Git prevents you from deleting code or other changes on a file by accident

-   Two weaknesses of git

    -   Git often struggles with binary files

    -   Git usually struggles with large files (e. g. huge datasets)

### e)

Knit this exercise sheet. Some new files will automatically be generated when knitting the sheet e.g. the HTML page. Ignore these files, as we only want to track the source files themselves. You can, but don't need to create a `.gitignore` file. Just do not commit these files manually.

## Exercise 2: Putting your Repository on GitHub (3 Points)

For this task you will upload your solution to GitHub.

### a)

Create a new repository on GitHub in your account named `exeRcise-sheet-3`. Make sure you create a **public repository** so we are able to see it for grading. Add the link to the repository below:

-   The link to the repository is provided [here](https://github.com/ATSzimmat/exeRcise-sheet-3)

### b)

Push your code to this new repository by copying and executing the snippet on github listed under " ...or push an existing repository from the command line".

### c)

Regularly push your latest changes to GitHub again and especially do so when you are finished with this sheet.

## Exercise 3: Pixar Films (4 Points)

Download the `pixar_films` and `public_response` datasets from the GitHub repository and track them in git.

Link: <https://github.com/rfordatascience/tidytuesday/tree/main/data/2025/2025-03-11>

For small datasets like these adding them to git is not a problem.

### a)

Load the `pixar_films` dataset into R. Clean the dataset by removing films without a title. Inspect the variable `film_rating`. What are the possible values and what do they mean? Create a factor variable for the film rating. Why is this appropriate?

```{r message=FALSE}
# Loading the dataset into R
pixar_data <- read_csv("data/pixar_films.csv")

# Revoming every film without a title
pixar_data <- pixar_data %>% filter(!is.na(film))

# Gaining insight into to the new dataset
pixar_data %>% head(10)

# Inspecting the variable film_rating
pixar_data$film_rating
```

-   The variable film_rating shows the suitability of a film for certain audiences based on its content. The possible values are based on the Motion Picture Association (MPA) film rating system.

-   There are 5 possible ratings in which the films can be classified (source: <https://www.filmratings.com/>)

    -   "G" (General Audiences) means that all ages are admitted

    -   "PG" (Parental Guidance Suggested) means that there is some material in the film that may not be suitable for children

    -   "PG-13" (Parents Strongly Cautioned) means that some material in the film may be inappropriate for children under 13

    -   "R" (Restricted) means that under 17 requires accompanying parent or adult guardian. The film contains some adult material.

    -   "NC-17" (Adults Only) means that the film is suitable only for persons older than 17 years.

    -   N/A means no rating is available

-   However, for this exercise only the ratings "G" and "PG" are relevant

```{r message=FALSE}
# Checking the type of the variable
typeof(pixar_data$film_rating)
# Creating a factor variable for the variable
pixar_data$film_rating <- as.factor(pixar_data$film_rating)
# Checking the type of the variable again
typeof(pixar_data$film_rating)
# Checking the possible values of the new factor variable
levels(pixar_data$film_rating)
```

-   This is appropriate because in R a factor variable has a fixed set of possible values and the film rating variable is based on the MPA film rating system which has such a fixed set of possible values

### b)

Inspect the film titles manually. Which films form a film series? A film series can be identified by a common word in the titles of the films, often in conjunction with a number in the title, e.g. "Despicable Me" and "Despicable Me 2". Create a dataframe which displays a list of the different series with the titles of the films and how many films belong to the series. Output the dataframe.

```{r message=FALSE}
# Inspecting the variable film titles
pixar_data$film
```

The following films form a series

-   Cars (Cars, Cars 2, Cars 3)

-   Finding Nemo (Finding Nemo, Finding Dory (because Finding Dory is a Sequel to Finding Nemo))

-   Monsters, Inc. (Monsters, Inc., Monsters University (because Monsters University is a Prequel to Monsters, Inc.))

-   The Incredibles (The Incredibles, Incredibles 2)

-   Toy Story (Toy Story, Toy Story 2, Toy Story 3, Toy Story 4, Lightyear (because Lightyear is a spin-off of the Toy Story series))

```{r}
# Creating the requested dataframe

# Creating a new variable that displays all the film titles without numbers; also I temporarily removed the article "the" from the film names because otherwhise it'll cause troubles
pixar_data_II <- pixar_data%>%
  mutate(film_series = str_remove(film, "^(The)\\s"),
film_series = str_remove(film_series, "\\s\\d+$"))

# Creating a dataframe that displays a list of the different series with the titles of the films and how many films belong to the series
pixar_data_II <- pixar_data_II %>%
  group_by(film_series) %>%
  summarise(
    films = paste(film, collapse = ", "),
    count = n())

# Now the article "The" is added again to two film series
pixar_data_II <- pixar_data_II %>%
                 mutate(film_series = case_when(film_series == "Incredibles" ~
                                  "The Incredibles",
                                  film_series == "Good Dinosaur" ~ 
                                  "The Good Dinosaur", TRUE ~ film_series)) 

#  a small correction ...
pixar_data_II <- pixar_data_II %>% 
                 mutate(films = case_when(films == "Finding Nemo" ~
  "Finding Nemo, Finding Dory",
  films == "Monsters, Inc." ~ 
  "Monsters Inc., Monsters University", 
  films == "Toy Story, Toy Story 2, Toy Story 3, Toy Story 4" ~
  "Toy Story, Toy Story 2, Toy Story 3, Toy Story 4, Lightyear", TRUE ~ films)) %>% slice(-c(5, 10, 12))

# Gaining insight into to the new dataframe
pixar_data_II %>% head(10)

# For the next exercises we'll need the table in a different format
pixar_data_III <- pixar_data_II %>% mutate(film_series = case_when(film_series == "Monsters, Inc." ~ "Monsters Inc.", TRUE ~ film_series))
pixar_long <- pixar_data_III %>%
  separate_rows(films, sep = ",\\s*") %>% rename(film = films, series =   film_series) %>% select(series, film)
# Gaining insight into to the new dataset
pixar_long %>% head(10)
```

### c)

Load the `public_response` dataframe into R. Convert the `cinema_score` variable into a factor while ensuring the factor levels are defined in ascending order, from the lowest to the highest score. Combine `public_response` with the `pixar_films` dataset using an appropriate merge variable.

```{r message=FALSE}
# Loading the dataset into R
response_data <- read_csv("data/public_response.csv")

# Checking the type of the cinema_score variable
typeof(response_data$cinema_score)

# Defining the grade levels
grade_levels <- c("D-", "D", "D+", "C-", "C", "C+", "B-", "B", "B+", "A-", "A", "A+")

# Converting the cinema_score variable into an ordered factor
response_data$cinema_score <- factor(response_data$cinema_score, levels = grade_levels)

# A small correction
pixar_data <- pixar_data %>% mutate(film = case_when(film == "Monsters, Inc." ~ "Monsters Inc.", TRUE ~ film))
response_data <- response_data %>% mutate(film = case_when(film == "Monsters, Inc." ~ "Monsters Inc.", TRUE ~ film))

# Adding the releasedate

pixar_release <- pixar_data %>% select(film,release_date)
pixar_release_II <- full_join(pixar_long, pixar_release, by = "film")

# Combining the pixar_long and public_response datasets   
pixar_and_response_data <- full_join(pixar_release_II, response_data, by = "film")

# Gaining insight into to the new dataset
pixar_and_response_data %>% head(10)
```

### d)

Choose one of the variables representing the public response and create a bar plot for the films belonging to a series. Here are the details of the plot: The film series are represented on the x-axis. Your chosen public response variable is displayed on the y-axis. Each film in the series is represented as a separate bar. Bars are grouped by film under their respective series on the x-axis. Order the bars within a series according to the release date of the films. A title and axis labels for context.

-   I chose the variable rotten_tomatoes

-   In the Rotten Tomatoes rating system, films are awarded a percentage points from 0 to 100. The higher the percentage score, the better it is rated.

```{r}
# First, the dataset needs to be adjusted a little
pixar_and_response_data_II <- pixar_and_response_data %>% select(series, film, release_date, rotten_tomatoes)
# The films for which no Rotten Tomatoes rating is available should be removed
pixar_and_response_data_II <- pixar_and_response_data_II %>% drop_na()
# Ensuring that the films within a series are sorted by release date
pixar_and_response_data_II <- pixar_and_response_data_II %>% arrange(series, release_date) %>%
 mutate(film = factor(film, levels = unique(film)))
```

```{r}
# Generating of a random color palette that , thanks to the Polychrome package, is suitable for color-blind people, but also does not represent a color gradient that could impair the readability of the graph
palette_pixar<- createPalette(15, c("#000000", "#FFD700"))
names(palette_pixar) <- unique(pixar_and_response_data_II$series)

# Creating the plot; for better readability of the plot, the label of the X axis was rotated by 90 degrees and the legend was moved to the position above the plot 
response_plot <- ggplot(pixar_and_response_data_II, aes(x = film, y = rotten_tomatoes, fill = series)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(x = "film", y = "Rotten Tomatoes Score", title = "Rotten Tomatoes Ratings of different Pixar Films") + 
  theme(legend.position = "top") +
  scale_fill_manual(values = palette_pixar)

response_plot
```

What do you notice when comparing the scores of the films in a series? Do you see any patterns?

-   As can be seen in the plot, the individual films in a series received similar ratings (e.g., all Toy Story films received almost 100 percentage points, while all three Cars films performed relatively poorly). Furthermore, it can be observed that in most cases, in a series with multiple films, the sequels always performed worse than their predecessors, and series thus might performe worse as the number of films increased.

## Exercise 4: Open Analysis (4 points)

This exercise is a bit more open-ended. You can choose any dataset from [Our World in Data](https://ourworldindata.org/) and analyze it, while determining the research question yourself.

### a)

Go to <https://github.com/owid/owid-datasets/tree/master/datasets> and choose a dataset that interests you. You can have a look at <https://ourworldindata.org/> to gather some inspiration.

-   I have chosen a dataset that shows the proportion of children born outside of marriage per year in different countries

### b)

Download the dataset and track it in git.

```{r message=FALSE}
# I will also load the dataset now into R
birth_data <- read_csv("data/Births outside of marriage.csv")
# Gaining insight into the dataset
birth_data %>% head(10)
```

### c)

Put the name / title of the dataset and a link to it below.

-   Dataset Name: Births outside of marriage
-   Link: <https://github.com/owid/owid-datasets/blob/master/datasets/Births%20outside%20of%20marriage/Births%20outside%20of%20marriage.csv>

### d)

Come up with a (research) question you want to answer with the data and briefly explain why you believe this is an interesting question within one sentence. It should be a question that can be answered with the dataset and using R.

-   My research question will be: "In which of the countries studied was the proportion of births out of marriage the highest or lowest in most years?"
-   This research question seems interesting to me, among other things, because the birth rate allows, to a certain extent, statements about, for example, the dominant values of a country or how much it is valued to have children only in marriage.

### e)

Use R to answer your chosen question. Please limit your analysis to the functions and techniques we have covered so far in the course. You are **not expected** to use advanced statistical models or external packages which haven't been introduced.

```{r message=FALSE}
# Data Wrangling

#First, the names should be made more manageable
birth_data <- birth_data %>% clean_names()

# Since there is not a measurement for every year for every country included in the dataset, the missing years should be filled

# To facilitate this, the data set is first converted to wide format. Moreover the dataset is arranged by year
birth_data_II <- birth_data %>% pivot_wider(names_from = 'entity' ,values_from = births_outside_of_marriage_percent_of_all_births) %>% arrange(year)

# Some countries have a very high number of NAs and are considered not to be sufficiently meaningful for the research question (guideline: if more than 1/3 of the values are NAs)

# Remove columns with too many NAs
threshold <- 1/3
birth_data_III <- birth_data_II %>%
  select(
    year,
    where(~ mean(is.na(.)) <= threshold))
birth_data_III

# The remaining NAs are replaced by the value of the previous year or, if this is not available (e.g. if the NA occurred in the oldest measurement year of the data set), by the oldest available value

birth_data_IV <- birth_data_III %>%
  fill(-year, .direction = "down") %>%
  fill(-year, .direction = "up")

# Checking if there are any NAs left
nrow(birth_data_IV) == nrow(birth_data_V <- birth_data_IV %>% drop_na())
# Since the output shows the same number two times, there are no missings left

# Now the dataset can be converted back to long format
birth_data_VI <- birth_data_IV %>%  pivot_longer(-year, names_to = "country", values_to = "value")

# Gaining insight into the modified dataset
birth_data_VI %>% head(10)
```

```{r}
# First we have to create a dataset that shows the country with the highest rate of out of marriage births for each year
# If two countries ranked first in this statistic in a year with the same score, both countries will be listed as first place
birth_data_VI_max <- birth_data_VI %>% group_by(year) %>% 
                     filter(value == max(value)) %>% ungroup()

# Now we can create a dataset that shows the countries that were most often ranked first in this statistic, in descending order
birth_data_VI_max_II <- birth_data_VI_max %>% 
  count(country, name = "count") %>% 
  arrange(desc(count))
# Gaining insight into the final table
birth_data_VI_max_II

# Now the same steps are being taken for the countries with the lowest rate of children born out of marriage
birth_data_VI_min <- birth_data_VI %>% group_by(year) %>% 
                     filter(value == min(value)) %>% ungroup()

birth_data_VI_min_II <- birth_data_VI_min %>% 
  count(country, name = "count") %>% 
  arrange(desc(count))
# Gaining insight into the final table
birth_data_VI_min_II
```

### f)

Create a meaningful plot / figure with the dataset. Make sure to provide a figure caption (via the chunk options / Rmarkdown) and correctly label the figure

-   In this exercise I'll create a plot which shows the development of rate of out of marriage births for each year in Europe (at least from the European countries included in the dataset and don't have too many NAs)

-   Since, as shown in the last exercise, Iceland and Sweden had the highest rates across all years included in the data set, these countries should receive special attention in the plot

-   To illustrate the development across Europe, we will first calculate the average of the values for all European countries for each year. To highlight the developments in Sweden and Iceland, there should also be calculated an average excluding Sweden and Iceland

-   But first the data set needs to be adjusted a bit

```{r message=FALSE}
# First, names should be made more manageable
birth_data_VII <- birth_data_IV %>% clean_names()
# Then, all non-European countries should be removed
birth_data_VIII <- birth_data_VII %>% select(-new_zealand) 
birth_data_VIII <- birth_data_VIII %>% select(-united_states)
# And finally, some pivotting is necessary
birth_data_VIII <- birth_data_VIII %>%  pivot_longer(-year, names_to = "country", values_to = "value")
# Gaining insight into the modified dataset
birth_data_VIII  %>% head(10)
```

```{r message=FALSE, fig.cap=" Fig. 1: Rate of out-of-marraige-births in Europe compared to Sweden and Iceland (1960-2014)"}
# Now the plot will be created

# Calculatung the average of all European countries 
birth_data_VIII_avg_all <- birth_data_VIII %>%
  group_by(year) %>%
  summarise(value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(country = "average (incl. all countries)")

# Calculating the average of all European countries except Iceland and Sweden
birth_data_VIII_avg_excl <- birth_data_VIII %>%
  filter(!country %in% c("iceland", "sweden")) %>%
  group_by(year) %>%
  summarise(value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  mutate(country = "average (excl. iceland and sweden)")

# Calculating values only for Iceland
data_iceland <- birth_data_VIII %>%
  filter(country == "iceland")

# Calculating values only for Sweden 
data_sweden <- birth_data_VIII %>%
  filter(country == "sweden")

# Combining all datasets
plot_data <- bind_rows(
  birth_data_VIII_avg_excl,
  birth_data_VIII_avg_all,
  data_iceland,
  data_sweden)

# Defining colors from the discreet viridis palette
viridis_colors <- viridisLite::viridis(4, option = "D")

# Creating the plot

ggplot(plot_data, aes(x = year, y = value, color = country)) +
  geom_line() +
  scale_color_manual(values = c(
    "average (excl. iceland and sweden)" = viridis_colors[1], 
    "average (incl. all countries)" = viridis_colors[2],
    "iceland" = viridis_colors[3], 
    "sweden" = viridis_colors[4])) +
  labs(
    x = "Year",
    y = "Rate of out-of-marraige-births",
    color = "Legend")

```

-   As you can see in the plot, the values ​​for Sweden and Iceland are consistently above the average for European countries (both with and without Sweden and Iceland).

-   While the difference between these two countries' values ​​and the European average was still quite small in the first years covered by the dataset (especially in Sweden), it rose rapidly, (especially in the 1970s and 1980s), and is still clearly visible in the figures for the 2010s.

## Final Note

Make sure to push all your commits and changes to GitHub before submitting the exercise sheet.
